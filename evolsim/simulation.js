// Generated by CoffeeScript 1.7.1
(function() {
    var ALWAYS_REPRODUCE, Blob, Gene, GeneCode, QTNode, QuadTree, Simulation, Vector2D, maxByIndex, minByIndex, randomSign, sim;

    randomSign = function() {
        if (Math.random() > .5) {
            return 1;
        } else {
            return -1;
        }
    };

    maxByIndex = function(arrayOfArrays, index) {
        "Get the maximum Array in an Array of Arrays according to \nordering by one of the indexes\ne.g. maxByElem [[\"hello\", 1], [\"goodbye\", 2]], 1 -> [\"goodbye\", 2]";
        var arr, maxArray, maxIndex, _i, _len;
        if (!arrayOfArrays.length) {
            return null;
        }
        maxIndex = arrayOfArrays[0][index];
        maxArray = arrayOfArrays[0];
        for (_i = 0, _len = arrayOfArrays.length; _i < _len; _i++) {
            arr = arrayOfArrays[_i];
            if (arr[index] > maxIndex) {
                maxIndex = arr[index];
                maxArray = arr;
            }
        }
        if (maxIndex == null) {
            throw new Error("maxByIndex: Index out of bounds for entire array");
        }
        return maxArray;
    };

    minByIndex = function(arrayOfArrays, index) {
        "Get the minimum Array in an Array of Arrays according to \nordering by one of the indexes\ne.g. minByElem [[\"hello\", 1], [\"goodbye\", 2]], 1 -> [\"goodbye\", 2]";
        var arr, minArray, minIndex, _i, _len;
        if (!arrayOfArrays.length) {
            return null;
        }
        minIndex = arrayOfArrays[0][index];
        minArray = arrayOfArrays[0];
        for (_i = 0, _len = arrayOfArrays.length; _i < _len; _i++) {
            arr = arrayOfArrays[_i];
            if (arr[index] < minIndex) {
                minIndex = arr[index];
                minArray = arr;
            }
        }
        if (minIndex == null) {
            throw new Error("minByIndex: Index out of bounds for entire array");
        }
        return minArray;
    };

    Math.PI2 = 2 * Math.PI;

    Vector2D = (function() {
        var name, _fn, _i, _len, _ref;

        _ref = ['add', 'subtract', 'multiply', 'divide'];
        _fn = function(name) {
            return Vector2D[name] = function(a, b) {
                return a.copy()[name](b);
            };
        };
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            name = _ref[_i];
            _fn(name);
        }

        Vector2D.randomUnitVector = function() {
            var v;
            v = new Vector2D(Math.random() - .5, Math.random() - .5);
            return v.normalize();
        };

        Vector2D.randomVector = function(xMax, yMax) {
            return new Vector2D(Math.random() * xMax, Math.random() * yMax);
        };

        Vector2D.randomBoundedVector = function(xMin, xMax, yMin, yMax) {
            var v;
            v = Vector2D.randomVector(xMax - xMin, yMax - yMin);
            return v.add(new Vector2D(xMin, yMin));
        };

        Vector2D.randomHeading = function() {
            return Math.random() * Math.PI2;
        };

        Vector2D.negateHeading = function(h) {
            return (h + Math.PI) % Math.PI2;
        };

        Vector2D.headingVector = function(h) {
            return new Vector2D(Math.cos(h), Math.sin(h));
        };

        function Vector2D(x, y) {
            var _ref1;
            if (x == null) {
                x = 0;
            }
            if (y == null) {
                y = 0;
            }
            _ref1 = [x, y], this.x = _ref1[0], this.y = _ref1[1];
        }

        Vector2D.prototype.copy = function() {
            return new Vector2D(this.x, this.y);
        };

        Vector2D.prototype.magnitude = function() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
        };

        Vector2D.prototype.normalize = function() {
            var m;
            m = this.magnitude();
            if (m > 0) {
                this.divide(m);
            }
            return this;
        };

        Vector2D.prototype.limit = function(max) {
            if (this.magnitude() > max) {
                this.normalize();
                return this.multiply(max);
            } else {
                return this;
            }
        };

        Vector2D.prototype.heading = function() {
            return (Math.atan2(this.y, this.x) + Math.PI2) % Math.PI2;
        };

        Vector2D.prototype.eucl_distance = function(other) {
            var dx, dy;
            dx = this.x - other.x;
            dy = this.y - other.y;
            return Math.sqrt(dx * dx + dy * dy);
        };

        Vector2D.prototype.distSq = function(other) {
            var dx, dy;
            dx = this.x - other.x;
            dy = this.y - other.y;
            return dx * dx + dy * dy;
        };

        Vector2D.prototype.distance = function(other, dimensions) {
            var dx, dy;
            if (dimensions == null) {
                dimensions = false;
            }
            dx = Math.abs(this.x - other.x);
            dy = Math.abs(this.y - other.y);
            if (dimensions) {
                dx = dx < dimensions.width / 2 ? dx : dimensions.width - dx;
                dy = dy < dimensions.height / 2 ? dy : dimensions.height - dy;
            }
            return Math.sqrt(dx * dx + dy * dy);
        };

        Vector2D.prototype.subtract = function(other) {
            this.x -= other.x;
            this.y -= other.y;
            return this;
        };

        Vector2D.prototype.add = function(other) {
            this.x += other.x;
            this.y += other.y;
            return this;
        };

        Vector2D.prototype.divide = function(n) {
            var _ref1;
            _ref1 = [this.x / n, this.y / n], this.x = _ref1[0], this.y = _ref1[1];
            return this;
        };

        Vector2D.prototype.multiply = function(n) {
            var _ref1;
            _ref1 = [this.x * n, this.y * n], this.x = _ref1[0], this.y = _ref1[1];
            return this;
        };

        Vector2D.prototype.dot = function(other) {
            return this.x * other.x + this.y * other.y;
        };

        Vector2D.prototype.projectOnto = function(other) {
            return other.copy().multiply(this.dot(other));
        };

        Vector2D.prototype.wrapToBound = function(xBound, yBound) {
            this.x = (this.x + xBound) % xBound;
            return this.y = (this.y + yBound) % yBound;
        };

        Vector2D.prototype.constrainToBound = function(xBound, yBound) {
            if (this.x < 0) {
                this.x = 0;
            }
            if (this.x > xBound) {
                this.x = xBound;
            }
            if (this.y < 0) {
                this.y = 0;
            }
            if (this.y > yBound) {
                return this.y = yBound;
            }
        };

        Vector2D.prototype.wrapRelativeTo = function(location, dimensions) {
            var a, d, key, map_d, v, _ref1;
            v = this.copy();
            _ref1 = {
                x: "width",
                y: "height"
            };
            for (a in _ref1) {
                key = _ref1[a];
                d = this[a] - location[a];
                map_d = dimensions[key];
                if (Math.abs(d) > map_d / 2) {
                    if (d > 0) {
                        v[a] = (map_d - this[a]) * -1;
                    } else {
                        v[a] = this[a] + map_d;
                    }
                }
            }
            return v;
        };

        Vector2D.prototype.invalid = function() {
            return (this.x === Infinity) || isNaN(this.x) || this.y === Infinity || isNaN(this.y);
        };

        return Vector2D;

    })();

    QuadTree = (function() {
        "Maintain a QuadTree of objects on a 2D space.\nEach object is represented by a unique id and has an associated 2D point.\nMaps from IDs to Vector2D points, and back.\nPoints do not uniquely identify an Id,Point combo because\nmultiple IDs may share the same location. IDs\nmust be unique.\nNOTE: QuadTree may break if >bucketSize points have exact same coordinate\nSuggest fixing by adding tiny random disturbance to avoid this situation";

        function QuadTree(xBound, yBound, bucketSize) {
            this.xBound = xBound;
            this.yBound = yBound;
            this.bucketSize = bucketSize;
            this.id2point = {};
            this.numPoints = 0;
            this.tree = new QTNode(this.xBound / 2, this.yBound / 2, this.xBound / 2, this.yBound / 2, this.bucketSize);
        }

        QuadTree.prototype.addObject = function(id, point) {
            var _ref, _ref1;
            if (!((0 <= (_ref = point.x) && _ref <= this.xBound) && (0 <= (_ref1 = point.y) && _ref1 <= this.yBound))) {
                throw new Error("Index out of bounds: " + point.x + ", " + point.y);
            }
            if (id in this.id2point) {
                throw Error("Object ID collision on id: " + id);
            }
            this.id2point[id] = point;
            this.tree.addPoint(id, point);
            return ++this.numPoints;
        };

        QuadTree.prototype.removeObject = function(id) {
            var p;
            if (!(id in this.id2point)) {
                throw Error("Tried to remove ID that isn't in map");
            }
            p = this.id2point[id];
            this.tree.removePoint(id, p);
            delete this.id2point[id];
            return --this.numPoints;
        };

        QuadTree.prototype.moveObject = function(id, newPoint) {
            this.removeObject(id);
            return this.addObject(id, newPoint);
        };

        QuadTree.prototype.calculateDistance = function(id1, id2) {
            var p1, p2;
            p1 = this.id2point[id1];
            p2 = this.id2point[id2];
            return p1.eucl_distance(p2);
        };

        QuadTree.prototype.circleQuery = function(centerPoint, radius) {
            "Returns a list of all object IDs that fall within the circle";
            return this.tree.circleQuery(centerPoint, radius, radius * radius);
        };

        QuadTree.prototype.approximateCircleQuery = function(centerPoint, radius) {
            "Returns a list of all object IDs that fall in nodes that intersect the circle";
            return this.tree.approximateCircleQuery(centerPoint, radius, radius * radius);
        };

        QuadTree.prototype.rebuild = function() {
            var id, oldPoints, pt, _results;
            this.tree = new QTNode(this.xBound / 2, this.yBound / 2, this.xBound / 2, this.yBound / 2, this.bucketSize);
            oldPoints = this.id2point;
            this.id2point = {};
            _results = [];
            for (id in oldPoints) {
                pt = oldPoints[id];
                _results.push(this.addObject(id, pt));
            }
            return _results;
        };

        QuadTree.prototype.resize = function(xBound, yBound) {
            this.xBound = xBound;
            this.yBound = yBound;
            return this.rebuild();
        };

        return QuadTree;

    })();

    QTNode = (function() {
        function QTNode(x, y, xEdge, yEdge, bucketSize, depth) {
            var MM, MP, PM, PP;
            this.x = x;
            this.y = y;
            this.xEdge = xEdge;
            this.yEdge = yEdge;
            this.bucketSize = bucketSize;
            this.depth = depth != null ? depth : 0;
            this.leaf = true;
            this.points = {};
            this.nPoints = 0;
            MM = new Vector2D(this.x - this.xEdge, this.y - this.yEdge);
            MP = new Vector2D(this.x - this.xEdge, this.y + this.yEdge);
            PM = new Vector2D(this.x + this.xEdge, this.y - this.yEdge);
            PP = new Vector2D(this.x + this.xEdge, this.y + this.yEdge);
            this.corners = [MM, MP, PM, PP];
        }

        QTNode.prototype.addPoint = function(id, p) {
            var id_, idx, p_, pts, _results;
            this.nPoints++;
            this.points[id] = p;
            if (this.leaf) {
                if (this.nPoints > this.bucketSize) {
                    this.leaf = false;
                    this.createChildren();
                    this.nPoints = 0;
                    pts = this.points;
                    this.points = {};
                    _results = [];
                    for (id_ in pts) {
                        p_ = pts[id_];
                        _results.push(this.addPoint(id_, p_));
                    }
                    return _results;
                }
            } else {
                idx = 2 * (p.x > this.x) + (p.y > this.y);
                return this.children[idx].addPoint(id, p);
            }
        };

        QTNode.prototype.createChildren = function() {
            var MM, MP, PM, PP, newXEdge, newYEdge;
            if (this.children != null) {
                throw new Error("Non-leaf node tried to make children");
            }
            newXEdge = this.xEdge / 2;
            newYEdge = this.yEdge / 2;
            if (this.depth > 4000) {
                self.postDebug(this.points);
            }
            MM = new QTNode(this.x - newXEdge, this.y - newYEdge, newXEdge, newYEdge, this.bucketSize, this.depth + 1);
            MP = new QTNode(this.x - newXEdge, this.y + newYEdge, newXEdge, newYEdge, this.bucketSize, this.depth + 1);
            PM = new QTNode(this.x + newXEdge, this.y - newYEdge, newXEdge, newYEdge, this.bucketSize, this.depth + 1);
            PP = new QTNode(this.x + newXEdge, this.y + newYEdge, newXEdge, newYEdge, this.bucketSize, this.depth + 1);
            return this.children = [MM, MP, PM, PP];
        };

        QTNode.prototype.removePoint = function(id, p) {
            var idx;
            if (!(id in this.points)) {
                throw new Error("Tried to remove id not in QTNode");
            }
            delete this.points[id];
            --this.nPoints;
            if (!this.leaf) {
                idx = 2 * (p.x > this.x) + (p.y > this.y);
                return this.children[idx].removePoint(id, p);
            }
        };

        QTNode.prototype.nearbyPoints = function(centerPoint, maxDist) {
            var distSq, grandparent, id, idx, parent, pt, pts, _ref, _ref1, _results;
            if (this.leaf) {
                distSq = maxDist * maxDist;
                parent = (_ref = this.parent) != null ? _ref : this;
                grandparent = (_ref1 = parent.parent) != null ? _ref1 : parent;
                pts = grandparent.points;
                _results = [];
                for (id in pts) {
                    pt = pts[id];
                    if (centerPoint.distSq(pt) <= distSq) {
                        _results.push(id);
                    }
                }
                return _results;
            } else {
                idx = 2 * (centerPoint.x > this.x) + (centerPoint.y > this.y);
                return this.children[idx].nearbyPoints(centerPoint, maxDist);
            }
        };

        QTNode.prototype.circleQuery = function(centerPoint, radius, radiusSq) {
            var c, id, intersect, minDist2Corner, pt, xDist, yDist, _ref, _ref1, _results;
            intersect = false;
            xDist = Math.abs(centerPoint.x - this.x);
            yDist = Math.abs(centerPoint.y - this.y);
            intersect || (intersect = xDist <= this.xEdge && yDist <= this.yEdge + radius);
            intersect || (intersect = yDist <= this.yEdge && xDist <= this.xEdge + radius);
            minDist2Corner = Math.min.apply(Math, (function() {
                var _i, _len, _ref, _results;
                _ref = this.corners;
                _results = [];
                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                    c = _ref[_i];
                    _results.push(centerPoint.distSq(c));
                }
                return _results;
            }).call(this));
            intersect || (intersect = minDist2Corner <= radiusSq);
            if (intersect) {
                if (this.leaf) {
                    _ref = this.points;
                    _results = [];
                    for (id in _ref) {
                        pt = _ref[id];
                        if (centerPoint.distSq(pt) <= radiusSq) {
                            _results.push(id);
                        }
                    }
                    return _results;
                } else {
                    return (_ref1 = []).concat.apply(_ref1, (function() {
                        var _i, _len, _ref1, _results1;
                        _ref1 = this.children;
                        _results1 = [];
                        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                            c = _ref1[_i];
                            _results1.push(c.circleQuery(centerPoint, radius, radiusSq));
                        }
                        return _results1;
                    }).call(this));
                }
            } else {
                return [];
            }
        };

        QTNode.prototype.approximateCircleQuery = function(centerPoint, radius, radiusSq) {
            var c, id, intersect, minDist2Corner, pt, xDist, yDist, _ref, _ref1, _results;
            intersect = false;
            xDist = Math.abs(centerPoint.x - this.x);
            yDist = Math.abs(centerPoint.y - this.y);
            intersect || (intersect = xDist <= this.xEdge && yDist <= this.yEdge + radius);
            intersect || (intersect = yDist <= this.yEdge && xDist <= this.xEdge + radius);
            minDist2Corner = Math.min.apply(Math, (function() {
                var _i, _len, _ref, _results;
                _ref = this.corners;
                _results = [];
                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                    c = _ref[_i];
                    _results.push(centerPoint.distSq(c));
                }
                return _results;
            }).call(this));
            intersect || (intersect = minDist2Corner <= radiusSq);
            if (intersect) {
                if (this.leaf) {
                    _ref = this.points;
                    _results = [];
                    for (id in _ref) {
                        pt = _ref[id];
                        _results.push(id);
                    }
                    return _results;
                } else {
                    return (_ref1 = []).concat.apply(_ref1, (function() {
                        var _i, _len, _ref1, _results1;
                        _ref1 = this.children;
                        _results1 = [];
                        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                            c = _ref1[_i];
                            _results1.push(c.approximateCircleQuery(centerPoint, radius, radiusSq));
                        }
                        return _results1;
                    }).call(this));
                }
            } else {
                return [];
            }
        };

        return QTNode;

    })();

    ALWAYS_REPRODUCE = false;

    GeneCode = (function() {
        "The genes for a particular blob. This determines the stats and\nAI for the blob. The stats are Attack, Speed, Photosynthesis, and \nefficiency. The AI is structured as a neural net with the gene's \nenergy level and nearby observable objects as inputs, and with \npursue(object), flee(object), reproduce() as output nodes.\nThe blob will take the action with the signal that most exceeds\nits threshold, or no action if no signals exceed threshold";
        GeneCode.copy = function(genecode) {
            var key, newGenes, oldGene, _ref;
            newGenes = {};
            _ref = genecode.genes;
            for (key in _ref) {
                oldGene = _ref[key];
                newGenes[key] = Gene.copy(oldGene);
            }
            return new GeneCode(newGenes);
        };

        function GeneCode(genes) {
            var atk_pho_total, spd_eff_total;
            this.genes = genes;
            if (this.genes == null) {
                this.genes = {
                    atk: new Gene(null, 0, 100),
                    spd: new Gene(null, 0, 100),
                    pho: new Gene(null, 0, 100),
                    eff: new Gene(null, 0, 100),
                    red: new Gene(null, 0, 255, 1),
                    grn: new Gene(null, 0, 255, 1),
                    blu: new Gene(null, 0, 255, 1),
                    huntBase: new Gene(null, -10000, 10000, 100),
                    fleeBase: new Gene(null, -10000, 10000, 100),
                    reprBase: new Gene(null, -10000, 10000, 100),
                    huntMod: new Gene(),
                    fleeMod: new Gene(),
                    reprMod: new Gene(null, 0),
                    nrgHunt: new Gene(),
                    atkHunt: new Gene(),
                    spdHunt: new Gene(),
                    phoHunt: new Gene(),
                    effHunt: new Gene(),
                    dstHunt: new Gene(),
                    clrHunt: new Gene(),
                    nrgFlee: new Gene(),
                    atkFlee: new Gene(),
                    spdFlee: new Gene(),
                    phoFlee: new Gene(),
                    effFlee: new Gene(),
                    dstFlee: new Gene(),
                    clrFlee: new Gene(),
                    childEnergy: new Gene(null, 0, 1000, 1)
                };
            }
            if (self.C.TWO_TRADEOFF) {
                atk_pho_total = this.genes.atk.val + this.genes.pho.val;
                spd_eff_total = this.genes.spd.val + this.genes.eff.val;
            } else {
                atk_pho_total = this.genes.atk.val + this.genes.pho.val + this.genes.spd.val + this.genes.eff.val;
                spd_eff_total = atk_pho_total;
            }
            this.atk = this.genes.atk.val / atk_pho_total * 100;
            this.pho = this.genes.pho.val / atk_pho_total * 100;
            this.spd = this.genes.spd.val / spd_eff_total * 100;
            this.eff = this.genes.eff.val / spd_eff_total * 100;
            this.red = this.genes.red.val;
            this.grn = this.genes.grn.val;
            this.blu = this.genes.blu.val;
        }

        GeneCode.prototype.chooseAction = function(energy, observables) {
            var action, actions, fleeAction, fleePairs, fleeSignal, fleeThreshold, huntAction, huntPairs, huntSignal, huntThreshold, maxAction, maxFlee, maxHunt, o, reprAction, reprSignal, reprThreshold, _ref, _ref1;
            if (ALWAYS_REPRODUCE) {
                return {
                    "type": "repr",
                    "argument": 0
                };
            }
            huntPairs = (function() {
                var _i, _len, _results;
                _results = [];
                for (_i = 0, _len = observables.length; _i < _len; _i++) {
                    o = observables[_i];
                    _results.push([this.calcHuntImpulse(o), o]);
                }
                return _results;
            }).call(this);
            fleePairs = (function() {
                var _i, _len, _results;
                _results = [];
                for (_i = 0, _len = observables.length; _i < _len; _i++) {
                    o = observables[_i];
                    _results.push([this.calcFleeImpulse(o), o]);
                }
                return _results;
            }).call(this);
            maxHunt = (_ref = maxByIndex(huntPairs, 0)) != null ? _ref : [0, null];
            maxFlee = (_ref1 = maxByIndex(fleePairs, 0)) != null ? _ref1 : [0, null];
            huntThreshold = this.genes.huntBase.val + this.genes.huntMod.val * energy;
            fleeThreshold = this.genes.fleeBase.val + this.genes.fleeMod.val * energy;
            reprThreshold = this.genes.reprBase.val + this.genes.reprMod.val * energy;
            huntSignal = this.genes.huntMod.val * energy + this.genes.huntBase.val + maxHunt[0];
            fleeSignal = this.genes.fleeMod.val * energy + this.genes.fleeBase.val + maxFlee[0];
            reprSignal = this.genes.reprMod.val * energy + this.genes.reprBase.val;
            fleeAction = [fleeSignal, 'flee', maxFlee[1]];
            huntAction = [huntSignal, 'hunt', maxHunt[1]];
            reprAction = [reprSignal, 'repr', this.genes.childEnergy.val];
            actions = [huntAction, fleeAction, reprAction];
            maxAction = maxByIndex(actions, 0);
            action = {
                "type": null
            };
            if (maxAction[0] > 0) {
                action.type = maxAction[1];
                action.argument = maxAction[2];
            }
            return action;
        };

        GeneCode.prototype.calcColorDist = function(b) {
            var dblu, dgrn, dred;
            dred = Math.abs(b.red - this.red);
            dgrn = Math.abs(b.grn - this.grn);
            dblu = Math.abs(b.blu - this.blu);
            return dred + dgrn + dblu - 10;
        };

        GeneCode.prototype.calcHuntImpulse = function(_arg) {
            var b, dist, i;
            b = _arg[0], dist = _arg[1];
            i = this.genes.nrgHunt.val * b.energy;
            i += this.genes.atkHunt.val * (b.atk - this.atk);
            i += this.genes.spdHunt.val * (b.spd - this.spd);
            i += this.genes.phoHunt.val * b.pho;
            i += this.genes.effHunt.val * b.eff;
            i += this.genes.dstHunt.val * dist;
            return i += this.genes.clrHunt.val * this.calcColorDist(b);
        };

        GeneCode.prototype.calcFleeImpulse = function(_arg) {
            var b, dist, i;
            b = _arg[0], dist = _arg[1];
            i = this.genes.nrgFlee.val * b.energy;
            i += this.genes.atkFlee.val * (b.atk - this.atk);
            i += this.genes.spdFlee.val * (b.spd - this.atk);
            i += this.genes.phoFlee.val * b.pho;
            i += this.genes.effFlee.val * b.eff;
            i += this.genes.dstFlee.val * dist;
            return i += this.genes.clrFlee.val * this.calcColorDist(b);
        };

        return GeneCode;

    })();

    Gene = (function() {
        "Represent a single gene in the GeneCode. Has method for mutation.\nIn future, plan to change so it references GeneCode and gets mutability\ninfo from GeneCode. Could be made more efficient by having GeneCodes with\nthe same Gene share references to the object.";
        Gene.copy = function(old) {
            var newGene;
            newGene = new Gene(old.val, old.min, old.max, old.mutationSize);
            return newGene.mutate();
        };

        function Gene(val, min, max, mutationSize) {
            this.val = val;
            this.min = min != null ? min : -100;
            this.max = max != null ? max : 100;
            this.mutationSize = mutationSize != null ? mutationSize : 5;
            if (this.val == null) {
                this.val = Math.random() * (this.max - this.min) + this.min;
            }
            this.mutationProbability = self.C.MUTATION_PROBABILITY;
        }

        Gene.prototype.mutate = function() {
            var mutationSize, sign;
            if (Math.random() < this.mutationProbability) {
                sign = randomSign();
                mutationSize = this.mutationSize * 2 * Math.random() * self.C.MUTATION_CONSTANT;
                this.val += sign * mutationSize;
                this.val = Math.max(this.val, this.min);
                this.val = Math.min(this.val, this.max);
            }
            return this;
        };

        return Gene;

    })();

    Blob = (function() {
        function Blob(simulation, id, energy, geneCode, pos) {
            this.simulation = simulation;
            this.id = id;
            this.energy = energy != null ? energy : 0;
            this.geneCode = geneCode;
            this.pos = pos;
            this.age = 0;
            this.id += '';
            if (this.geneCode == null) {
                this.geneCode = new GeneCode();
            }
            this.pho = this.geneCode.pho;
            this.atk = this.geneCode.atk;
            this.spd = this.geneCode.spd;
            this.eff = this.geneCode.eff;
            this.red = this.atk * 2.55;
            this.grn = this.pho * 2.55;
            this.blu = this.spd * 2.55;
            this.nucleus_red = this.geneCode.red;
            this.nucleus_grn = this.geneCode.grn;
            this.nucleus_blu = this.geneCode.blu;
            this.currentHeading = null;
            this.maxMovement = this.spd * self.C.MOVEMENT_SPEED_FACTOR;
            this.reproSpeedFactor = (100 - this.spd) / 100;
            this.stepsUntilNextAction = 0;
            this.stepsUntilNextQuery = 0;
            this.alive = true;
            this.neighborDists = {};
            this.calculateEnergyAndRadius();
        }

        Blob.prototype.calculateEnergyAndRadius = function() {
            this.efficiencyFactor = 1 - (this.eff / 100) * .75;
            this.energyPerSecond = this.pho * (this.pho * self.C.PHO_SQ_EPS + self.C.PHO_EPS);
            this.energyPerSecond -= (this.atk * (this.atk * self.C.ATK_SQ_EPS + self.C.ATK_EPS)) * this.efficiencyFactor;
            this.energyPerSecond += this.spd * self.C.SPD_EPS * this.efficiencyFactor;
            this.energyPerSecond -= self.C.AGE_ENERGY_DECAY * this.age * this.age;
            this.attackPower = this.atk * this.atk;
            return this.calculateRadius();
        };

        Blob.prototype.calculateRadius = function() {
            this.rad = Math.sqrt(this.energy) * self.C.RADIUS_FACTOR + self.C.RADIUS_CONSTANT;
            return this.rad *= self.C.BLOB_SIZE;
        };

        Blob.prototype.preStep = function() {
            "One full step of simulation for this blob.\nAttackables: Everything which is adjacent and close enough to\nauto-attack. These are passed by the simulation";
            var n;
            this.attackedThisTurn = {};
            this.attackEnergyThisTurn = 0;
            this.numAttacks = 0;
            this.movedLastTurn = this.movedThisTurn;
            this.movedThisTurn = 0;
            this.energy += this.energyPerSecond;
            this.age++;
            this.energy *= 1 - self.C.ENERGY_DECAY;
            "Neighbors: Everything within seeing distance. Represented as\nlist of blobs. Querying only once every 10 steps, so force-recalc\ndistance for each neighbor everytime.";
            if (this.stepsUntilNextQuery <= 0) {
                this.neighbors = this.simulation.getNeighbors(this.id);
                return this.stepsUntilNextQuery = 10;
            } else {
                this.neighbors = (function() {
                    var _i, _len, _ref, _results;
                    _ref = this.neighbors;
                    _results = [];
                    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                        n = _ref[_i];
                        if (n.alive) {
                            _results.push(n);
                        }
                    }
                    return _results;
                }).call(this);
                return this.stepsUntilNextQuery--;
            }
        };

        Blob.prototype.getObservables = function() {
            var dist, move_so_far, n, _base, _i, _j, _len, _len1, _name, _ref, _ref1, _ref2, _results;
            _ref = this.neighbors;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                n = _ref[_i];
                if (this.neighborDists[n.id] != null) {
                    _ref1 = this.neighborDists[n.id], dist = _ref1[0], move_so_far = _ref1[1];
                    move_so_far += this.movedLastTurn + n.movedLastTurn;
                    if (move_so_far > self.C.MOVE_UPDATE_AMT) {
                        delete this.neighborDists[n.id];
                    }
                }
                if ((_base = this.neighborDists)[_name = n.id] == null) {
                    _base[_name] = [this.simulation.blobDist(this, n), 0];
                }
            }
            _ref2 = this.neighbors;
            _results = [];
            for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
                n = _ref2[_j];
                _results.push([n, this.neighborDists[n.id][0]]);
            }
            return _results;
        };

        Blob.prototype.chooseAction = function() {
            if (this.maintainCurrentAction > 0) {
                if (this.action.type === "hunt" && !this.simulation.isAlive(this.huntTarget.id)) {
                    this.maintainCurrentAction = 0;
                } else {
                    this.maintainCurrentAction--;
                    return;
                }
            }
            this.action = this.geneCode.chooseAction(this.energy, this.getObservables());
            if (this.action.type === "hunt") {
                if (this.huntTarget) {
                    this.huntTarget = this.action.argument[0];
                    this.maintainCurrentAction = 20;
                }
            }
            if (this.action.type === "repr") {
                this.maintainCurrentAction = Math.round(self.C.REPR_TIME_REQUIREMENT * this.reproSpeedFactor + Math.random());
                return this.reproducing = true;
            }
        };

        Blob.prototype.handleMovement = function() {
            var distance, heading, moveAmt, targetBlob, _ref, _ref1;
            if (this.action.type === "hunt") {
                if (this.action.argument != null) {
                    _ref = this.action.argument, targetBlob = _ref[0], distance = _ref[1];
                    heading = this.simulation.getHeading(this.id, targetBlob.id);
                    moveAmt = distance - 3;
                    this.wandering = null;
                } else {
                    if (this.wandering == null) {
                        this.wandering = Vector2D.randomHeading();
                    }
                    heading = this.wandering;
                    moveAmt = this.maxMovement;
                }
            } else if (this.action.type === "flee" && (this.action.argument != null)) {
                _ref1 = this.action.argument, targetBlob = _ref1[0], distance = _ref1[1];
                heading = this.simulation.getHeading(this.id, targetBlob.id);
                heading = Vector2D.negateHeading(heading);
                moveAmt = this.maxMovement;
                this.wandering = null;
            } else {
                this.wandering = null;
            }
            if ((heading != null) && (moveAmt != null)) {
                return this.move(heading, moveAmt);
            }
        };

        Blob.prototype.handleAttacks = function() {
            var aBlob, amt, attackDelta, dist, _i, _len, _ref, _ref1;
            _ref = this.getObservables();
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                _ref1 = _ref[_i], aBlob = _ref1[0], dist = _ref1[1];
                if (dist < this.rad + aBlob.rad + 1) {
                    attackDelta = this.attackPower - aBlob.attackPower;
                    if (attackDelta >= 0) {
                        this.numAttacks++;
                        aBlob.numAttacks++;
                        amt = Math.min(attackDelta, aBlob.energy);
                        this.energy += amt;
                        this.attackEnergyThisTurn += amt;
                        aBlob.energy -= attackDelta;
                        aBlob.attackEnergyThisTurn -= attackDelta + 5;
                    }
                    this.energy -= self.C.ATTACK_BURN;
                }
            }
            if (isNaN(this.attackEnergyThisTurn)) {
                self.postDebug(this);
                return self.postDebug("NAN attack energy");
            }
        };

        Blob.prototype.wrapUp = function(pos) {
            this.pos = pos;
            if (this.action.type === "repr") {
                if (this.maintainCurrentAction === 0) {
                    this.reproduce(this.action.argument);
                    this.reproducing = null;
                }
            }
            this.calculateEnergyAndRadius();
            if (this.energy < 0 || isNaN(this.energy)) {
                this.simulation.removeBlob(this.id);
                return this.alive = false;
            }
        };

        Blob.prototype.move = function(heading, moveAmt) {
            moveAmt = Math.min(moveAmt, this.maxMovement, this.energy * self.C.MOVEMENT_PER_ENERGY / this.efficiencyFactor);
            moveAmt = Math.max(moveAmt, 0);
            this.energy -= moveAmt * this.efficiencyFactor / self.C.MOVEMENT_PER_ENERGY;
            this.simulation.moveBlob(this.id, heading, moveAmt);
            this.neighborDists = {};
            return this.movedThisTurn = moveAmt;
        };

        Blob.prototype.reproduce = function(childEnergy) {
            var childGenes;
            if (this.energy <= self.C.REPR_ENERGY_COST) {
                if (self.C.HARSH_REPRODUCTION) {
                    this.energy -= self.C.REPR_ENERGY_COST / 2;
                }
                return;
            }
            if (childEnergy > (this.energy - self.C.REPR_ENERGY_COST) / 2) {
                if (self.C.HARSH_REPRODUCTION) {
                    this.energy -= self.C.REPR_ENERGY_COST / 2;
                }
                return;
            }
            if (this.energy >= childEnergy + self.C.REPR_ENERGY_COST * this.efficiencyFactor) {
                this.energy -= childEnergy + self.C.REPR_ENERGY_COST * this.efficiencyFactor;
                childGenes = GeneCode.copy(this.geneCode);
                return this.simulation.addChildBlob(this.id, childEnergy, childGenes);
            }
        };

        return Blob;

    })();

    Simulation = (function() {
        function Simulation() {
            this.initialized = false;
        }

        Simulation.prototype.initialize = function() {
            this.initialized = true;
            this.blobs = {};
            this.qtree = new QuadTree(self.C.X_BOUND, self.C.Y_BOUND, self.C.QTREE_BUCKET_SIZE);
            this.nBlobs = 0;
            this.nextBlobId = 0;
            this.observedBlobID = null;
            this.blobsRemovedThisStep = [];
            return this.blobsAddedThisStep = {};
        };

        Simulation.prototype.processMessage = function(msg) {
            var i, _i, _ref, _results;
            if (!(this.initialized || msg.type === "updateConstants")) {
                self.postDebug("Recieved msg " + msg + " while uninitialized");
                return;
            }
            switch (msg.type) {
                case "go":
                    this.step();
                    return this.postBlobData();
                case "killAllBlobs":
                    return this.killAllBlobs();
                case "killMostBlobs":
                    return this.killMostBlobs();
                case "addRandomBlob":
                    return this.addRandomBlob();
                case "addBlobs":
                    _results = [];
                    for (i = _i = 0, _ref = msg.data; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
                        _results.push(this.addRandomBlob());
                    }
                    return _results;
                    break;
                case "updateConstants":
                    self.C = msg.data;
                    self.postDebug(self.C);
                    if (!this.initialized) {
                        this.initialize();
                    }
                    if (self.C.X_BOUND !== this.qtree.xBound || self.C.Y_BOUND !== this.qtree.yBound) {
                        return this.resize();
                    }
            }
        };

        Simulation.prototype.resize = function() {
            var id, pos, xBound, yBound, _ref;
            xBound = self.C.X_BOUND;
            yBound = self.C.Y_BOUND;
            _ref = this.qtree.id2point;
            for (id in _ref) {
                pos = _ref[id];
                if (pos.x > xBound || pos.y > yBound) {
                    this.removeBlob(id);
                }
            }
            return this.qtree.resize(self.C.X_BOUND, self.C.Y_BOUND);
        };

        Simulation.prototype.postBlobData = function() {
            var blob, blobStates, id, msg, _ref;
            blobStates = {};
            _ref = this.blobs;
            for (id in _ref) {
                blob = _ref[id];
                blobStates[id] = [blob.pos.x, blob.pos.y, blob.rad];
            }
            msg = {
                type: 'blobs',
                blobs: blobStates,
                added: this.blobsAddedThisStep,
                removed: this.blobsRemovedThisStep
            };
            return postMessage(msg);
        };

        Simulation.prototype.observeBlob = function(xCoord, yCoord) {
            var b, clickLocation, nearbyBlobs, prevId, selected;
            self.postDebug("Called observeBlob with " + xCoord + "," + yCoord);
            clickLocation = new Vector2D(xCoord, yCoord);
            if (this.observedBlob != null) {
                prevId = this.observedBlob.id;
                this.observedBlob.observed = null;
                this.observedBlob = null;
            }
            nearbyBlobs = this.getAdjacent(clickLocation, 80);
            nearbyBlobs = (function() {
                var _i, _len, _results;
                _results = [];
                for (_i = 0, _len = nearbyBlobs.length; _i < _len; _i++) {
                    b = nearbyBlobs[_i];
                    _results.push([b, clickLocation.distSq(this.qtree.id2point[b.id])]);
                }
                return _results;
            }).call(this);
            selected = minByIndex(nearbyBlobs, 1);
            if ((selected != null) && selected[1] < selected[0].rad + 10 && selected[0].id !== prevId) {
                selected = selected[0];
                this.observedBlob = selected;
                self.postDebug("Observing blob:" + this.observedBlob.id);
                return this.observedBlob.observed = true;
            }
        };

        Simulation.prototype.step = function() {
            var blob, id, _ref, _ref1, _ref2, _ref3, _results;
            // if (this.nBlobs > 300) {
 //     self.C.PHO_EPS = -0.1;
 //     self.C.PHO_SQ_EPS = 0;
 // } else if (this.nBlobs < 10) {
 //     self.C.PHO_EPS = 1.5;
 //     self.C.PHO_SQ_EPS = 0.3;
 // } else {
 //     self.C.PHO_SQ_EPS = 0.2;
 //     self.C.PHO_EPS = 0.5;
 // }

            this.blobsRemovedThisStep = [];
            this.qtree.rebuild();
            _ref = this.blobs;
            for (id in _ref) {
                blob = _ref[id];
                blob.preStep();
                blob.chooseAction();
            }
            _ref1 = this.blobs;
            for (id in _ref1) {
                blob = _ref1[id];
                blob.handleMovement();
            }
            _ref2 = this.blobs;
            for (id in _ref2) {
                blob = _ref2[id];
                blob.handleAttacks();
            }
            _ref3 = this.blobs;
            _results = [];
            for (id in _ref3) {
                blob = _ref3[id];
                _results.push(blob.wrapUp(this.qtree.id2point[id]));
            }
            return _results;
        };

        Simulation.prototype.getNeighbors = function(blobID) {
            var pos, rad;
            pos = this.qtree.id2point[blobID];
            rad = this.blobs[blobID].rad;
            return this.getAdjacent(pos, self.C.NEIGHBOR_DISTANCE + rad * 1.5, blobID);
        };

        Simulation.prototype.getAdjacent = function(position, distance, blobID) {
            var otherID, queryResult, _i, _len, _results;
            queryResult = this.qtree.approximateCircleQuery(position, distance);
            _results = [];
            for (_i = 0, _len = queryResult.length; _i < _len; _i++) {
                otherID = queryResult[_i];
                if (otherID !== blobID) {
                    _results.push(this.blobs[otherID]);
                }
            }
            return _results;
        };

        Simulation.prototype.getHeading = function(sourceID, targetID) {
            var sourcePos, targetPos;
            sourcePos = this.qtree.id2point[sourceID];
            targetPos = this.qtree.id2point[targetID];
            return Vector2D.subtract(targetPos, sourcePos).heading();
        };

        Simulation.prototype.moveBlob = function(blobID, heading, moveAmt) {
            var moveVector, newPos, sourcePos;
            sourcePos = this.qtree.id2point[blobID];
            moveVector = Vector2D.headingVector(heading).multiply(moveAmt);
            newPos = moveVector.add(sourcePos);
            newPos.constrainToBound(self.C.X_BOUND, self.C.Y_BOUND);
            return this.qtree.moveObject(blobID, newPos);
        };

        Simulation.prototype.addBlob = function(position, energy, geneCode) {
            var b;
            b = new Blob(this, this.nextBlobId, energy, geneCode, position);
            this.blobs[this.nextBlobId] = b;
            this.blobsAddedThisStep[this.nextBlobId] = [b.red, b.grn, b.blu, b.nucleus_red, b.nucleus_grn, b.nucleus_blu];
            this.qtree.addObject(this.nextBlobId, position);
            this.nextBlobId++;
            return this.nBlobs++;
        };

        Simulation.prototype.addRandomBlob = function() {
            var pos;
            pos = Vector2D.randomBoundedVector(0, self.C.X_BOUND, 0, self.C.Y_BOUND);
            self.postDebug(self.C.STARTING_ENERGY);
            return this.addBlob(pos, self.C.STARTING_ENERGY);
        };

        Simulation.prototype.addChildBlob = function(parentID, childEnergy, childGenes) {
            var childOffset, childPosition, parentPosition, parentRadius, parentSpeed;
            parentPosition = this.qtree.id2point[parentID];
            parentRadius = this.blobs[parentID].rad;
            parentSpeed = this.blobs[parentID].spd;
            childOffset = Vector2D.randomUnitVector();
            childOffset.multiply(self.C.CHILD_DISTANCE + parentRadius + parentSpeed / 2);
            childPosition = childOffset.add(parentPosition);
            childPosition.constrainToBound(self.C.X_BOUND, self.C.Y_BOUND);
            return this.addBlob(childPosition, childEnergy, childGenes);
        };

        Simulation.prototype.removeBlob = function(blobID) {
            if ((this.observedBlob != null) && this.observedBlob.id === blobID) {
                this.observedBlob = null;
            }
            this.blobs[blobID].alive = false;
            delete this.blobs[blobID];
            this.qtree.removeObject(blobID);
            this.blobsRemovedThisStep.push(blobID);
            return this.nBlobs--;
        };

        Simulation.prototype.killAllBlobs = function() {
            var blob, blobID, _ref, _results;
            _ref = this.blobs;
            _results = [];
            for (blobID in _ref) {
                blob = _ref[blobID];
                _results.push(this.removeBlob(blobID));
            }
            return _results;
        };

        Simulation.prototype.killMostBlobs = function() {
            var blob, blobID, _ref, _results;
            _ref = this.blobs;
            _results = [];
            for (blobID in _ref) {
                blob = _ref[blobID];
                if (!(Math.random() < .05)) {
                    _results.push(this.removeBlob(blobID));
                } else {
                    _results.push(void 0);
                }
            }
            return _results;
        };

        Simulation.prototype.isAlive = function(blobID) {
            return blobID in this.blobs;
        };

        Simulation.prototype.blobDistSq = function(blob1, blob2) {
            var p1, p2;
            p1 = this.qtree.id2point[blob1.id];
            p2 = this.qtree.id2point[blob2.id];
            return p1.distSq(p2);
        };

        Simulation.prototype.blobDist = function(blob1, blob2) {
            return Math.sqrt(this.blobDistSq(blob1, blob2));
        };

        return Simulation;

    })();

    self.postDebug = function(msg) {
        return self.postMessage({
            type: 'debug',
            msg: msg
        });
    };

    sim = new Simulation();

    this.onmessage = (function(_this) {
        return function(event) {
            return sim.processMessage(event.data);
        };
    })(this);

}).call(this);
